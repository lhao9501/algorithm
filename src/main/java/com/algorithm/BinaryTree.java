package com.algorithm;

/**
 *      1、节点的度
 *              子树（子节点）的个数
 *         树的度
 *               所有节点中节点的度的最大值
 *
 *      2、层数：
 *              根节点所在层为第一层，根节点的子节点所在层为第二层，以此类推（不同教材不同约定）
 *         高度（从下到上）：
 *              节点的高度：
 *                      从当前节点到其叶子节点的唯一路径的路径长度或者经过的节点总数（不同教材不同约定）
 *              树的高度：
 *                      所有节点的高度的最大值
 *         深度（从上到下）：
 *              节点的深度：
 *                      从根节点到当前节点的唯一路径的路径长度或者经过的节点总数（不同教材不同约定）
 *              树的深度：
 *                      所有节点的深度的最大值
 *
 *      3、二叉树性质
 *              每个节点的度最大为2
 *              非空二叉树第 i 层，最多有 2^(i-1)个节点(i>=1)
 *              高度为 h 的二叉树最多有 2^h - 1个节点(h>=1)
 *                      2^h - 1 = 2^0 + 2^1 + ... + 2^(h-1)
 *              对于任意非空二叉树，如果叶子节点个数为n0, 度为2的节点个数为n2, 则有n0 = n2 + 1;
 *                      总节点数为n, 度为1的节点为n1, n = n0 + n1 + n2
 *                      路径为 0*n0 + 1*n1 + 2*n2 = n - 1
 *
 *       4、二叉树的种类
 *              真二叉树：
 *                      所有节点的度要么是0，要么是2
 *
 *              满二叉树：
 *                      所有节点的度要么是0，要么是2，且所有的叶子节点都在最有一层
 *                      同样高度的二叉树中，满二叉树的节点数量是最多的
 *
 *              完全二叉树：
 *                      叶子节点只能出现在最后2层，最后1层的叶子节点都靠左对齐
 *                      度为1的节点只有左子树，度为1的节点要么是1个那么是0个
 *                      同样节点数量的二叉树，完全二叉树的高度最小
 *                      假设完全二叉树的高度为 h(h>=1)，那么：
 *                          至少有 2^(h-1)个节点   即2^0 + 2^1 + ... + 2^(h-2) + 1  最后一层仅有一个节点
 *                          至多有 2^h - 1个节点   即满二叉树
 *                          如果该完全二叉树的总节点数量为 n，有不等关系:
 *                              2^(h-1) <= n <= 2^h - 1 < 2^h
 *                              h - 1 <= log2(n) < h
 *                              h = floor(log2(n)) + 1
 *
 *                              这里举例说明上面的式子：
 *                                  比如有  5 - 1 <= x < 5  ===>   5 <=  x + 1  < 5 + 1  ===> x取值为 [4,5), x的上下幅度不能超过1,因此只能向下取整。
 *
 *                      假设完全二叉树的总节点数量为 n, 叶子节点个数为n0, 度为1的节点为n1, 度为2的节点个数为n2:
 *                          n0 = n2 + 1;
 *                          n = n0 + n1 + n2;
 *                          ===> n = 2*n0 + n1 - 1;
 *                          n1要么为0，要么为1：
 *                              当n1 = 0时，有 n = 2*n0 - 1; n一定为奇数，非叶子节点数量为 n1+n2 = (n-1)/2
 *                              当n1 = 1时，有 n = 2*n0;     n一定为偶数，非叶子节点数量为 n1+n2 = n/2
 *
 *                          总结一下：
 *                              当n为偶数时，一定  有度为1的节点，叶子节点 n0 = n/2;
 *                              当n为奇数时，一定没有度为1的节点，叶子节点 n0 = (n+1)/2;
 *                              所以 n不管为偶数还是奇数，叶子节点数量为 n0 = floor((n+1)/2) = ceiling(n/2);
 *                                                     非叶子节点数量为 n1 = floor(n/2) = ceiling((n-1)/2).
 *
 *
 *        5、B-树
 *              B树是平衡的多路搜索树，一个节点可以存储超过2个元素，可以拥有超过2个子节点;
 *              每个节点的子树高度一致，所有的叶子节点都在同一层上。
 *
 *              m阶B树的性质(m>=2)
 *                  假设一个节点存储的元素个数为 x：
 *                      根节点元素个数：   1 <= x <= m-1
 *                      非根节点元素个数： ceiling(m/2)-1 <= x <= m-1
 *
 *                      如果该节点有子节点，子节点的个数：y = x + 1
 *                          根节点子节点个数：   2 <= y <= m
 *                          非根节点子节点个数： ceiling(m/2) <= y <= m
 *
 *                   如 m=3, 2<=y<=3, 称为(2,3)树、2-3树
 *                   如 m=4, 2<=y<=4, 称为(2,4)树、2-3-4树
 *                   如 m=5, 3<=y<=5, 称为(3,5)树
 *                   ...
 *
 *              添加：
 *                  新添加的元素必定是添加到叶子节点上。
 *
 *                  添加导致上溢(overflow)问题：
 *                      新元素添加到叶子节点上，导致该叶子节点上的元素数量 > m-1(即数量=m)
 *                  上溢解决：
 *                      假设上溢节点最中间元素的位置为 k,将 k 位置的元素向上与父节点合并。
 *                      将[0, k-1]和[k+1, m-1]位置的元素分裂成2个子节点，这2个子节点的元素个数都会 >= ceiling(m/2) - 1
 *                      一次分裂完，可能导致父节点上溢，依然按照上述方法解决。
 *                      最极端的情况，有可能一致分裂到根节点，这是唯一一种导致 B树长高的操作。
 *
 *              删除：
 *                  真正要删除的元素都发生在叶子节点中。
 *
 *                  要删除的元素在叶子节点，那么直接删除即可。
 *                  要删除的元素在非叶子节点，先找到其前驱或者后继元素，覆盖要删除的元素，在删除前驱或者后继元素。
 *                      非叶子节点中的元素的前驱或者后继元素，必定在叶子节点中。
 *
 *                  删除导致的下溢(underflow)问题：
 *                      叶子节点中的某个元素被删除，导致该节点元素数量 < ceiling(m/2)-1 (即数量=ceiling(m/2)-2)
 *                  下溢解决：
 *                      如果下溢节点的兄弟节点的元素数量 >= ceiling(m/2)，可以向其接一个元素(即旋转操作)：
 *                          将父节点的元素插入到下溢节点的 0位置(最小位置)，将兄弟节点中的最大位置的元素代替父节点中取走的元素。
 *                      如果下溢节点的兄弟节点的元素数量 = ceiling(m/2)-1，可以将父节点元素挪下来和左右子节点进行合并：
 *                          合并后的新节点的元素数量 = ceiling(m/2)-1 + ceiling(m/2)-2 + 1 <= m - 1
 *                          这个操作可能导致父节点下溢，依然按照上述方法解决。
 *                          最极端的情况，有可能传播到根节点，这是唯一一种导致 B树变矮的操作。
 *
 *
 *          6、红黑树(平衡二叉B树)
 *              性质：
 *                  1、节点是RED或者BLACK
 *                  2、根节点是BLACK
 *                  3、叶子节点(外部节点、空节点)都是BLACK
 *                  4、RED节点的子节点都是BLACK
 *                          RED节点的父节点都是BLACK
 *                          从 根节点 到 叶子节点 的所有路径上不能出现 2个连续的RED节点
 *                  5、从任意节点到 叶子节点的所有路径都包含相同数目的BLACK节点
 *
 *               红黑树 VS 4阶B树
 *                  具有等价性
 *                  BLACK节点和他的RED子节点融合在一起，形成一个B树节点
 *                  红黑树的BLACK节点总个数与4阶B树的节点总个数相等
 */
public class BinaryTree {

}















